<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viewer Queue</title>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1a1a1a;
            color: #e1e1e1;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            padding-top: 10px;
        }

        .top-bar {
            width: 100%;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 10px;
            position: absolute;
            top: 0;
            right: 10px;
        }

        #login-status {
            width: 60px;
            height: 60px;
            border-radius: 20%;
            object-fit: cover;
            display: none;
            flex-shrink: 0;
        }

        #login {
            background-color: #d16ce6;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            display: none;
            transition: background-color 0.3s;
        }

        #login:hover {
            background-color: #b04cc8;
        }

        .container {
            width: 95%;
            max-width: 900px;
            text-align: center;
            margin-top: 60px;
            flex-grow: 1;
        }

        h1 {
            color: #d16ce6;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #d16ce6;
            color: white;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #ff66cc;
        }

        #toggle-queue-button.open {
            background-color: #ff4b4b;
        }

        table {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
            background-color: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 2px solid #333;
        }

        th {
            background-color: #ff66cc;
            color: #ffffff;
            font-size: 20px;
        }

        @media (max-width: 768px) {
            th, td {
                font-size: 1rem;
                padding: 6px;
            }
        }
        #notification {
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: none;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        tr:hover td {
            background: #ff66cc;
            color: white;
            transition: 0.3s ease-in-out;
        }
        #next-button, #toggle-queue-button {
            flex: 1;
            max-width: 150px;
        }

        #next-button:hover {
            background-color: #ff66cc;
        }
    
        #toggle-queue-button:hover {
            background-color: #ff66cc;
        }
        .group-row td {
            text-align: start; 
            font-weight: bold; 
            font-size: medium;
            background-color: #2b2b2b; 
            color: #ff66cc;
            padding: 12px 0; 
        }

        th:first-child, 
        td:first-child {
            width: 50px;
            text-align: center; 
            font-size: 1rem;
        }

        tbody tr {
            min-height: 40px; 
        }

        tr.draggable { cursor: grab; }
        tr.dragging { opacity: 0.5; background: #f0f0f0; }

        /* Copyable Bungie Name */
        .copyable {
            cursor: pointer;
            position: relative;
        }

        .copyable:hover {
            background-color: rgba(255, 102, 204, 0.5);
        }

        /* Feedback Animation */
        .copied {
            background-color: #d16ce6 !important;
            transition: background-color 0.3s ease-in-out;
        }

        .remove-button {
            padding: 5px 8px;
            border: none;
            border-radius: 3px;
            background-color: #ff4b4b;
            color: #ffffff;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background-color 0.3s;
        }

        .remove-button:hover {
            background-color: #cc3a3a;
        }
        /* Counter Style */
        #run-counter {
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
            margin: 5px 0;
        }
        .dropdown {
            position: relative;  /* Ensures the dropdown content is positioned relative to this container */
        }
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;  /* Aligns the dropdown menu to the left of the parent container */
            top: 100%;  /* Positions it directly below the image */
            background-color: #1a1a1a;
            min-width: 160px;
            box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
            z-index: 1;
            margin-top: 5px; /* Adds a small gap between the image and the dropdown */
        }

        /* When the dropdown is active, display it */
        .dropdown.active .dropdown-content {
            display: block;
        }

        img {
            cursor: pointer;
        }

        #dropdown-menu button {
            width: 100%;
            padding: 8px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="dropdown">
            <img id="login-status" alt="User Profile Picture" onclick="toggleDropdown()">
            <button id="login">Login with Twitch</button>
            <div id="dropdown-menu" class="dropdown-content">
                <span id="login-text"></span>
                <button onclick="viewerQueue()">Queue for viewers</button>
                <button onclick="aliasSite()">Alias Management</button>
                <button onclick="logout()">Logout</button>
            </div>
        </div>
    </div>
    <div class="container">
        <h1>Queue Viewer</h1>
        <div id="notification"></div>
        <!-- Input and Button Section -->
        <div class="button-container">
            <button id="next-button">Next</button>
            <button id="toggle-queue-button">Toggle Queue</button>
        </div>
        <div>Runs: <span id="run-counter">0</span></div>
        
        <!-- Queue Table -->
        <table>
            <thead>
                <tr>
                    <th>Pos</th>
                    <th>Twitch</th>
                    <th>Bungie</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="queue-body">
                <!-- Queue data will be populated here -->
            </tbody>
        </table>
    </div>

    <script>

        function toggleDropdown() {
            document.querySelector('.dropdown').classList.toggle('active');
        }
        function getSessionCookie(name) {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.startsWith(name + '=')) {
                    return cookie.substring(name.length + 1);
                }
            }
            return null;  // Return null if the cookie isn't found
        }
        function showNotification(message, type = "error") {
            const notification = document.getElementById("notification");
            notification.textContent = message;

            const styles = {
                error: { backgroundColor: "#f8d7da", color: "#721c24", borderColor: "#f5c6cb" },
                success: { backgroundColor: "#d4edda", color: "#155724", borderColor: "#c3e6cb" },
                info: { backgroundColor: "#d1ecf1", color: "#0c5460", borderColor: "#bee5eb" }
            };

            Object.assign(notification.style, styles[type]);
            notification.style.display = "block";

            setTimeout(() => {
                notification.style.display = "none";
            }, 5000);
        }
        const baseURL =
        window.location.hostname.includes("shuttle.app")
            ? "" // same origin on Shuttle (https://krapbott-xxx.shuttle.app)
            : "http://127.0.0.1:8000"; // local dev
        async function updateQueueToggleButton() {
            try {
                const response = await fetch(`${baseURL}/queue/state`);
                if (response.ok) {
                    const { is_open } = await response.json();
                    const toggleButton = document.getElementById("toggle-queue-button");
                    toggleButton.textContent = is_open ? "Close Queue" : "Open Queue";
                    toggleButton.style.backgroundColor = is_open ? "#ff4444" : "#44cc44";
                } else {
                    showNotification("Failed to fetch queue state.", "error");
                }
            } catch (error) {
                showNotification("Error fetching queue state.", "error");
            }
        }
        async function fetchQueueForChannel() {
            const tbody = document.getElementById("queue-body");
            tbody.innerHTML = "";
            try {
                const response = await fetch("/queue", {
                    method: "GET",
                    credentials: "include" // important so cookies go with the request
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }

                const groupedData = await response.json();
                console.log("Queue API response:", groupedData);

                if (groupedData.error === "Not logged in") {
                    window.location.href = "https://id.twitch.tv/oauth2/authorize?client_id=mtcgb9falyzs4n3j7x3rqr51ho9gxr&redirect_uri=https://krapbott-rajo.shuttle.app/auth/callback&response_type=code"; // redirect to your login page
                    return;
                }

                if (!Array.isArray(groupedData.queue)) {
                    showNotification("Unexpected response from server.");
                    return;
                }
                
                const queue = groupedData.queue;
                if (queue.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3">No data found for this channel.</td></tr>`;
                }
                const runCounterResponse = await fetch(`${baseURL}/queue/run-counter`, {
                    method: 'GET',
                    credentials: 'same-origin',
                });
                const { run_counter } = await runCounterResponse.json();

                // Update the run counter display
                document.getElementById("run-counter").textContent = run_counter;

                if (queue.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3">No data found for this channel.</td></tr>`;
                    return;
                }
        
                queue.forEach((group, index) => {
                    const groupRow = document.createElement("tr");
                    groupRow.classList.add("group-row");
                    groupRow.innerHTML = `<td colspan="4"><strong>Group ${index + 1}</strong></td>`;
                    tbody.appendChild(groupRow);
        
                    group.forEach(entry => {
                        const row = document.createElement("tr");
                        row.classList.add("draggable");
                        row.setAttribute("draggable", "true");
                        row.dataset.twitchName = entry.twitch_name;
                        row.dataset.position = entry.position;
                        row.innerHTML = `
                            <td>${entry.position}</td>
                            <td>${entry.twitch_name}</td>
                            <td class="copyable">${entry.bungie_name}</td>
                            <td><button class="remove-button" data-twitch="${entry.twitch_name}">Remove</button></td>
                        `;
                        tbody.appendChild(row);
                    });
                });
                
                document.querySelectorAll('.copyable').forEach(element => {
                    element.addEventListener('click', () => {
                        const textToCopy = element.textContent.trim();
                
                        // First, try Clipboard API
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(textToCopy)
                                .then(() => {
                                })
                                .catch(err => {
                                    fallbackExecCommandCopy(textToCopy);
                                });
                        } else {
                            // Fallback to execCommand
                            fallbackExecCommandCopy(textToCopy);
                        }
                    });
                });
                
                function fallbackExecCommandCopy(text) {
                    const textarea = document.createElement("textarea");
                    textarea.value = text;
                
                    // Hide the textarea off-screen
                    textarea.style.position = "fixed";
                    textarea.style.top = "-9999px";
                    document.body.appendChild(textarea);
                
                    // Select the text in the textarea
                    textarea.select();
                
                    try {
                        const successful = document.execCommand("copy");
                        if (successful) {
                        } else {
                        }
                    } catch (err) {
                        showNotification("Fallback copy failed:", err);
                    } finally {
                        // Remove the temporary textarea
                        document.body.removeChild(textarea);
                    }
                }

                // Add remove button functionality
                document.querySelectorAll('.remove-button').forEach(button => {
                    button.addEventListener('click', async () => {
                        const twitchName = button.getAttribute('data-twitch');
                        try {
                            const removeResponse = await fetch(`${baseURL}/queue/remove`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ twitch_name: twitchName}),
                                credentials: 'same-origin',
                            });

                            if (removeResponse.ok) {
                                fetchQueueForChannel();
                            } else {
                                showNotification("Failed to remove from queue.");
                            }
                        } catch (error) {
                            showNotification("Error removing user from queue.");
                        }
                    });
                });
            } catch (error) {
                console.error("Failed to fetch queue:", error);
                showNotification("Failed to fetch queue data. Please check the channel name and try again.");
            }
        }

        document.getElementById("toggle-queue-button").addEventListener("click", async function () {     
            const toggleButton = this;
            const isQueueOpen = toggleButton.textContent === "Close Queue";
            const action = isQueueOpen ? "close" : "open";
        
            try {
                const response = await fetch(`${baseURL}/queue/${action}`, {
                    method: "POST",
                    credentials: 'same-origin',
                });
        
                if (response.ok) {
                    const result = await response.json(); // Optional: log response for debugging
                    console.log(`Queue toggled: ${action}`, result);
        
                    // Update the button label and style
                    toggleButton.textContent = isQueueOpen ? "Open Queue" : "Close Queue";
                    toggleButton.style.backgroundColor = isQueueOpen ? "#44cc44" : "#ff4444";
                    showNotification(
                        isQueueOpen ? "Queue closed successfully." : "Queue opened successfully.",
                        "success"
                    );
                } else {
                    const errorText = await response.text();
                    console.error("Toggle queue error:", errorText);
                    showNotification("Failed to toggle queue state.", "error");
                }
            } catch (error) {
                console.error("Error toggling queue:", error);
                showNotification("Error toggling queue state.", "error");
            }
        });
        
        document.getElementById("login").addEventListener("click", function() {
            window.location.href = "https://id.twitch.tv/oauth2/authorize?client_id=mtcgb9falyzs4n3j7x3rqr51ho9gxr&redirect_uri=https://krapbott-rajo.shuttle.app/auth/callback&response_type=code";
        });

        function viewerQueue() {
            const profileName = document.getElementById('login-text')
            
            window.location.href = `/queue.html?streamer=${profileName.textContent}`;
        }
        function aliasSite() {
            window.location.href = '/alias.html';
        }

        document.getElementById("next-button").addEventListener("click", async function() {
            try {
                const response = await fetch(`${baseURL}/queue/next`, {
                    method: "POST",
                    credentials: "same-origin",
                });

                if (response.ok) {
                    const button = document.getElementById("next-button");
                    showNotification("Moved to the next entry!", "success");
                    button.disabled = true;
                    await fetchQueueForChannel();
                    button.disabled = false;
                } else {
                    showNotification("Failed to move to the next entry.", "error");
                }
            } catch (error) {
                showNotification("Error moving to the next entry.", "error");
            }
        });

        async function enableDragAndDrop() {
            const tbody = document.getElementById("queue-body");
            let draggedRow = null;
            let newQueueOrder = [];
    
            // Track if drag-and-drop is in progress
            let isDragging = false;
    
            tbody.addEventListener("dragstart", (event) => {
                if (event.target.classList.contains("draggable")) {
                    draggedRow = event.target;
                    draggedRow.classList.add("dragging");
                    isDragging = true;
                    //stopPolling();
                }
            });
    
            tbody.addEventListener("dragover", (event) => {
                event.preventDefault();
    
                // Only perform the reordering logic when a row is being dragged
                const targetRow = event.target.closest("tr.draggable");
                if (targetRow && draggedRow !== targetRow) {
                    const bounding = targetRow.getBoundingClientRect();
                    const offset = bounding.top + bounding.height / 2;
    
                    if (event.clientY - offset > 0) {
                        targetRow.after(draggedRow);
                    } else {
                        targetRow.before(draggedRow);
                    }
                }
            });
    
            tbody.addEventListener("dragend", async () => {
                draggedRow.classList.remove("dragging");
                draggedRow = null;
    
                // Capture the new order after the drop
                newQueueOrder = Array.from(tbody.querySelectorAll("tr.draggable"))
                    .map((row, index) => ({
                        position: index + 1,
                        twitch_name: row.dataset.twitchName,
                        bungie_name: row.cells[2].textContent.trim(),
                    }));
    
                if (isDragging) {
                    isDragging = false;  // Stop dragging
                    
                    if (newQueueOrder.length > 0) {
                        // Update queue order only when the drag ends successfully
                        await updateQueueOrder(newQueueOrder);
                    }
                }
            });
        }
        
        async function updateQueueOrder(newQueueOrder) {
            try {
                console.log(newQueueOrder);
                const response = await fetch(`${baseURL}/queue/reorder`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        "Cookie": document.cookie
                    },
                    body: JSON.stringify({ new_order: newQueueOrder}),
                    credentials: 'same-origin',
                });

                showNotification("Queue updated successfully!", "success");
                fetchQueueForChannel();
            } catch (error) {
                showNotification("Error updating queue. Please try again.", "error");
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            enableDragAndDrop();
        });
        
        async function checkLoginStatus() {
            try {
                const response = await fetch("/auth/session", { credentials: "include" });

                if (response.ok) {
                    const data = await response.json();
                    if (data.logged_in) {
                        document.getElementById('login').style.display = 'none';
                        const profileImg = document.getElementById('login-status');
                        profileImg.src = data.profile_pp || '';
                        profileImg.style.display = 'block';
                        document.getElementById('login-text').textContent = data.username;
                        return;
                    }
                }
                // Show login if not logged in or fetch failed
                document.getElementById('login').style.display = 'block';
            } catch (err) {
                console.error("Login check failed:", err);
                document.getElementById('login').style.display = 'block';
            }
        }

        async function logout() {
        try {
            // Optional: Clear cookies manually if needed
            document.cookie.split(";").forEach(function(c) {
                document.cookie = c
                    .replace(/^ +/, "")
                    .replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
            });
            // Redirect or reload the page
            window.location.reload();
            
        } catch (error) {
            showNotification("Error during logout.", "error");
            console.error("Logout error:", error);
        }
    }

        document.addEventListener("DOMContentLoaded", () => {
            checkLoginStatus();
            fetchQueueForChannel();
            enableDragAndDrop();
        });
        setInterval(() => {
            fetchQueueForChannel();
        }, 5000);
    </script>
</body>
</html>
